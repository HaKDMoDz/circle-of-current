=!AeroQuado64=

This is my PCB design for a quadrotor helicopter flight controller, based heavily on !AeroQuad.

This page is a rough guide for the first people to receive a PCB. More details will be added as development continues.

This page is not yet ready.

<img src="http://frank.circleofcurrent.com/junk/aq64_img/overview1.png" />

<img src="http://frank.circleofcurrent.com/junk/aq64_img/overview2.png" />

==Downloads==

These packages includes:

 * Arduino
  * sketch source code
  * core source code
 * Bootloader
  * ATmegaBOOT based
   * source code
   * .hex binaries
  * USBaspLoader based
   * source code
   * .hex binaries
 * !CadSoft EAGLE
  * schematic
  * board
  * library
  * design rules
  * CAM job

[http://code.googfdgle.dfgcom/p/circle-of-current/downloads/detail?name=AeroQudfgado64-2011fgd0413.zip Download version 20110413], compiles ok, nothing is tested, the PCBs were ordered yesterday...

=Table of Contents=

<wiki:toc max_depth="2" />

=Features=

 * ATmega644PA, 16 MHz, 64KB of flash memory, 4KB of SRAM memory 
 * Two serial ports, both are level shifted, and can be easily routed to different devices 
 * Plenty of pins for extra servos, digital and analog inputs, and digital outputs 
 * Code size large enough for all existing !AeroQuad code, even the stuff that only fits on the Arduino Mega and !AeroQuad Mega Shield
 * Supports ESCs which use RC pulse signals or I2C 
 * Supports the following !SparkFun breakout boards: ITG-3200 gyro, 6 DOF IMU, BMA180 accelerometer, BMP085 barometic pressure sensor, HMC5842 compass, IMU3000 IMU 
 * Circuitry for battery monitoring 
 * Connectors for FTDI cable, bluetooth, XBee, GPS, AVR programmer, V-USB, and more 
 * 3 LEDs and 1 power indicator LED 
 * Reset switch, and another switch that you can use 
 * Plenty of extra connectors, plenty of connection options 
 * Plenty of configurations options available 
 * Slotted corners allows for flexible mounting

 * PCB is 3.9 inch X 3.9 inch

=Assembly Guide and Circuit Walkthrough=

Note that all resistors are in 0805 packaging, although 0603 will also fit perfectly fine. They should be 1/16 watt or greater. Note that all capacitors, unless otherwise specified, are ceramic chip capacitors in 0805 packaging (or 0603 since they will also fit perfectly fine). They should be rated 16V or greater. 

This assembly guide also contains some notes about the various areas on the circuit.

==Microcontroller==

<img src="http://frank.circleofcurrent.com/junk/aq64_img/microcontroller1.png" />
<img src="http://frank.circleofcurrent.com/junk/aq64_img/microcontroller2.png" />

The ATmega644PA obviously must be installed, solder in a 40 pin DIP socket so you are able to replace the IC if you need to.

The ATmega644PA requires a 16 MHz resonator.

The resonator footprint also allows you to use a 16 MHz crystal in HC49 packaging, but if you do this, you must install two 27 pF capacitors to the underside of the board. You should only choose a 16 MHz crystal if you have a good reason not to use a 16 MHz resonator.

You must solder C1 and C2, which are 0.1 uF decoupling capacitors for the ATmega644PA. Also solder C9 which is a 0.1 uF decoupling capacitor for the analog reference.

On the bottom of the board, there is a footprint labelled "AREF-SEL", which allows you to choose the analog reference voltage by soldering over the pads labelled 5V or 3V3. You may also use a 0 ohm resistor here, or an ferrite bead. Note that AVCC is always connected to 5V.

==Microcontroller Supporting Areas==

<img src="http://frank.circleofcurrent.com/junk/aq64_img/mcusupport1.png" />
<img src="http://frank.circleofcurrent.com/junk/aq64_img/mcusupport2.png" />

The reset switch must be installed, `R`13 10K ohm is the pull-up resistor for the reset switch. This resistor is optional because the ATmega644PA has a built-in pull-up resistor on the reset pin. You should install this if you do not trust the built-in resistor.

A push button labelled "BOOT" can be installed only if you are using a non-Arduino-standard bootloader. I personally hate the way "time sensitive" bootloaders work. This button is active low and connected to PB6 on the ATmega. Be sure to enable internal pull-up resistors for this button.

The ISP header (labelled AVRISP) should be installed if you need to use an AVR programmer (perhaps to load the bootloader for the first time, etc). The long line at the side indicates the side that the "red wire" (also pin 1) of the cable should be, and the short line at the bottom indicates where the notch of the connector should be.

==LED Indicators==

<img src="http://frank.circleofcurrent.com/junk/aq64_img/leds1.png" />

LED1, LED2, LED3 are 3 mm LEDs, choose your own colours. They can be mounted vertically or horizontally (pointing out). Please watch the polarity indicated by the hole shape and silkscreen. `R`3, `R`4, and `R`5, are all 1K ohm resistors to limit current to these LEDs. They are 1K ohm instead of a lower value because the signals may be used for some other purpose later, you may substitute a lower resistance if you want brighter LEDs and do not want to experiment with native USB funtionality.

LED3 does not currently serve any purpose in the existing software, it is there for you to use for your own custom application. LED1 is conencted to PB0 (Sanguino pin 0), LED2 is connected to PB1 (Sanguino pin 1), and LED3 is connected to PB2 (Sanguino pin 2). LED1 and LED2 should perform the same functions as the two LEDs on the !AeroQuad V1.8 shield.

==Power Supply==

<img src="http://frank.circleofcurrent.com/junk/aq64_img/pwrsupply1.png" />

Solder a LM1117 3V3 regulator in SOT-233-3 packaging where indicated on the PCB. Also solder the accompanying C3, which is 1 uF.

LED-PWR is a 3 mm LED that indicates that there is power present on the 3V3 supply bus. You may solder this vertically or sideways (pointing out). `R`12 is the 1K ohm current limiting resistor for this LED.

Two rows of 3 pin male headers should be installed at "3V3-TAP", these headers give you access to the 3V3 supply bus. Two rows of 3 pin male headers should be installed at "5V-TAP", these headers give you access to the "SYS" 5V supply bus.

If you are powering this circuit from a battery, you must install a LM1117 5V regulator in SOT-233-3 packaging where indicated on the PCB. This may be omitted if you are using the ESCs as the power supply (be sure to set SJ1 correctly), or under other circumstances that you are under.

The 1 uF capacitor C4 should be always soldered regardless of whether or not you are using a 5V regulator.

The battery power input is used if you need to connect a battery. There are four ways to do this:

<img src="http://frank.circleofcurrent.com/junk/aq64_img/batteryoptions1.png" />

 * Using a barrel jack 
 * Solder wire directly onto PCB (you can enlarge some holes to act as strain relief) 
 * using a screw terminal 
 * Using a 3 pin header

A beefy diode should be installed at D2 to protect the circuit from a battery connected backwards (so omit this diode if you believe in your own competence, you must bridge the pads of the diode footprint with solder if you omit this diode). This must be a diode that can handle 20V of reverse voltage, and handle 1.5A of forward current. The footprint is SMB or similar.

C5 and C6 are aluminum electrolytic 5.3mm x 5.3mm capacitors that must be installed, solder them in the correct orientation according to polarity.

===Battery Monitor===

<img src="http://frank.circleofcurrent.com/junk/aq64_img/battmon1.png" />

If you want to use the battery voltage monitor capabilies, install D1 (1N4148 in MELF packaging), `R`7 (7K5 ohm), and `R`6 (15K ohm). There's a 3 pin header near these components labelled "BATT-MON" that you can use to connect the battery that you wish to monitor. Alternatively, bridging SJ16 will connect the battery supply to the battery monitor circuit instead. The battery monitor and battery supply sections are separated in case you use two separate batteries (one for motors, another for control electronics). Remember to enable the battery monitor software, and note that this is connected to analog channel 0 (PORTA's PA0).

Remember to measure the voltage drop across D1 and also the values of `R`6 and `R`7. Set these values in the software so the sampled data is accurate.

==Port A Auxiliary GPIOs==

<img src="http://frank.circleofcurrent.com/junk/aq64_img/portapins1.png" />

There are 7x3 headers connected to PORTA's pins PA1 to PA7. The top row of pins is ground, the voltage for the center row of pins is selectable, and the pins in the bottom row are connected to PORTA's pins. You must select the voltage for the center row according to how you plan to use them. These pins have no specific purpose and are meant for you to experiment with. Here are your options and how you should choose the voltage.

 * Control more servos    
  * Use SJ17 to power the servos via the system supply (might be weak) or the power supplied by the ESCs (recommended). 
 * Read more RC input channels    
  * Use SJ15 to connect the same voltage used by the RC input headers 
 * General purpose digital input/output    
  * Select either 5V or 3V3 using SJ15 and SJ2 together
 * Read in analog voltages    
  * Select either 5V or 3V3 using SJ15 and SJ2 together
 * Use with jumper shunt blocks    
  * Select ground using SJ15, also remember to enable the internal pull-up resistors on these pins

Important: If you select ground for SJ15, then do not select anything using SJ17, doing so will short-circuit the power supply connected to SJ17 with ground, which can cause damage to the various power supply components.

Important: If you select V-RC with SJ15 (to use the same voltage that the RC inputs are using) and you have selected 3V3 using SJ3, then you must not use SJ17 to select anything. Doing so will cause the 5V supply to be joined with the 3V3 supply, which can cause damage to 3V3 devices.

==RC Input==

<img src="http://frank.circleofcurrent.com/junk/aq64_img/rcinputpins1.png" />

PORTC's pins PC7 to PC2 are connected to 6x3 headers, solder in male headers here. These are dedicated to taking RC pulse signals from your RC receiver. The voltage for the center pin can be connected to 5V or 3V3 using SJ2, and remember that there is a "5V-TAP" and "3V-TAP" if your receiver needs power from a 7th cable.

Important: If you select V-RC with SJ15 (to use the same voltage that the RC inputs are using) and you have selected 3V3 using SJ3, then you must not use SJ17 to select anything. Doing so will cause the 5V supply to be joined with the 3V3 supply, which can cause damage to 3V3 devices.

==Sensors==

<img src="http://frank.circleofcurrent.com/junk/aq64_img/sensors1.png" />

Solder `R`1 and `R`2, which are 4K7 pull-up resistors for the I2C bus. Be sure that you disable internal pull-up resistors in the software. This allows you to use 3V3 I2C sensors without using a level shifter.

You may choose to install either the 6-DOF IMU (gyro and accelerometer combined) breakout board, or a ITG-3200 gyro breakout board. If you do choose the ITG-3200, you may then also choose to install a BMA180 accelerometer breakout board. You must always have a gyro but the accelerometer is optional (it allows you to enable auto-leveling flight). Be sure to configure this correctly in the software.

If you are feeling experimental, the IMU3000 breakout board also fits into the ITG-3200 breakout board footprint, with similar pin assignments.

You may also choose to install a BMP085 barometric sensor breakout board, and a HMC5842 compass breakout board. These are optional and you can configure the software to use them for altitude-hold and compass-heading-hold.

==Outputs to Motors and Servos==

<img src="http://frank.circleofcurrent.com/junk/aq64_img/variousoutputs1.png" />

Four sets of 3-pin male headers should be soldered near "ESC" labels, these are connections for standard RC pulse signal ESCs. SJ1 can be used to connect the voltage supplied by the ESCs to the main system supply bus.

Four sets of 4-pin headers can be soldered near "I2C-GROUP", these are meant for connections to any ESCs that use I2C. SJ3 Can be used to connect the 5V supply or 3V3 supply to the ESCs's supply voltage. Alternatively, if you wish to use only 3 wires to connect to I2C ESCs, then short the V+ pins of the I2C-GROUP headers with the ground pins, and DO NOT use SJ3 at all.

There's another 4-pin header also meant for an auxilliary I2C connection, SJ5 selects the voltage supplied to this connector. This connection is for experimentation with I2C devices. Personally, I think it's useful for connecting a logic analyzer to debug the I2C bus.

There's a set of four 3-pin headers labelled "SERVO" 1 to 4. Solder these if you have any servos to control (maybe for a camera? !AreoQuad supports camera control), you can also use these as general purpose digital input/output pins. SJ4 is used to select the power supply for these servos, either from the system 5V supply, or the 5V supplied by the ESCs (recommended). These pins are connected to PB3 to PB6.

==Native USB==

<img src="http://frank.circleofcurrent.com/junk/aq64_img/usbsection1.png" />

There is a section designed with [http://obdev.at/products/vusb/index.html V-USB circuitry] so the ATmega644PA can communicate with a computer via native low speed USB. This can be used to implement FTDI-less communication, bootloading, and configuration. This is current meant just for experimentation.

SJ18 is used to join the 5V power supply with the 5V coming from the computer's USB port, this is not recommended as the 5V from the computer is also connected to PB0 so that it can detect whether or not USB is connected.

Do not solder anything to the USB section unless you really want to experiment. It is possible for LED2 and LED3 to cause too much load on the USB bus, if you suspect that they are causing problems, uninstall `R`4 and `R`5.

C10 is a tantalum 4u7 capacitor, solder it on if you are playing with USB. This capacitor is polarized so install it in the right orientation as indicated. If you install a ceramic capacitor here, then most likely the orientation will not matter. `R`14 and `R`15 are 68 ohm terminating resistors for the D+ and D- signals of the USB bus, `R`16 is a 2K2 pull-up resistor which causes the computer to recognize the bus as low speed USB. D3 and D4 must be 3.6V zener diodes in MELF package (suggested 1N5227B, use 500 mW versions, will not work with 200 mW versions) which clamp the USB bus voltage.

==Serial Ports==

<img src="http://frank.circleofcurrent.com/junk/aq64_img/sersection1.png" />

There are a few possible serial port devices. The ATmega644PA has two serial ports, USART0 and USART1, they are probably labelled SER0 and SER1 on the PCB.

Use horizontal mount male headers for the FTDI cable connection. This connection is always powered by 5V, RX and TX are at 5V level. Use SJ9 and SJ10 to decide whether to connect this to SER0 or SER1.

There's a connection designed for a Bluetooth Mate (or BlueSMIRF), and since they don't come with default headers, you should decide between either male or female headers yourself. This connection is always powered by 5V, RX and TX are at 5V level. Use SJ7 and SJ8 to decide whether to connect this to SER0 or SER1.

There's a connection meant for a general purpose serial device (GPS, datalogger, etc). Use SJ13 and SJ14 to decide whether to connect this to SER0 or SER1. Use SJ6 to decide whether to power this device from 5V or 3V3. It is important to note that the RX and TX signals are always at 3V3 level regardless of the supplied power. You must install the level shifter circuit or bypass it correctly if you plan on using this connector.

Install 2 mm female headers on the XBee footprint if you plan on using a XBee radio module. This is always powered by 3V3, RX and TX always uses the level shifted serial signals. SJ11 and SJ12 are used to select between using SER0 and SER1 for the XBee module.

===Level Shifters===

<img src="http://frank.circleofcurrent.com/junk/aq64_img/levelshifting1.png" />
<img src="http://frank.circleofcurrent.com/junk/aq64_img/levelshifting2.png" />

If you plan on interfacing any 3V3 devices with the serial ports, you should implement the level shifting circuitry. XBee is known to not work well with 5V microcontrollers directly.

Each level shifter circuit uses a voltage divider for the TX signal and a TXB0101 (IC4 and IC5, SOT-23 package) bidirectional level translator for the RX signal. `R`9 (4K7 ohm), `R`8 (10K ohm) and IC4 are used for SER0. `R`10 (4K7 ohm), `R`11 (10K ohm) and IC5 are used for SER1. C7 and C8 (0.1 uF) are there to decouple the 3V3 and 5V supplies for IC4 and IC5. Do not omit C7 and C8 if either IC4 or IC5 is installed (otherwise, omit C7 and C8 if both IC4 and IC5 are omitted).

To bypass a level shifter circuit, short out the corresponding 4K7 ohm resistor footprint, omit the TXB0101, and join pin 3 and 4 (signal A and B) of the TXB0101 with a wire.

<img src="http://frank.circleofcurrent.com/junk/aq64_img/levelshifting_bypass.png" />

=Jumper Configuration Summary=

<img src="http://frank.circleofcurrent.com/junk/aq64_img/solderjumpers1.png" />

||AREF-SEL||Selects the analog reference voltage between 3V3 and 5V||
||SJ1||Joins the 5V from RC pulse ESCs to the 5V system power supply||
||SJ2||Selects 5V or 3V3 for the RC receiver signals||
||SJ3||Joins the power from I2C ESCs to either the 5V RC pulse ESCs power, or to 3V3 power. Alternatively, if you wish to use only 3 wires to connect to I2C ESCs, then short the V+ pins of the I2C-GROUP headers with the ground pins, and DO NOT use SJ3 at all.||
||SJ4||Selects 5V from the system supply or 5V from the ESCs for the auxiliary servos||
||SJ5||Selects 5V or 3V3 for the auxiliary I2C device connector||
||SJ6||Selects the voltage supplied to the auxiliary serial device, either 5V or 3V3||
||SJ7 and SJ8||Selects between SER0 and SER1 for the bluetooth connector||
||SJ9 and SJ10||Selects between SER0 and SER1 for the FTDI cable connector||
||SJ11 and SJ12||Selects between SER0 and SER1 for the XBee||
||SJ13 and SJ14||Selects between SER0 and SER1 for the auxiliary serial device||
||SJ15||Allows you to join the center pin of the PORTA headers to the same power used by the RC signal input headers, or to ground so you can use them with jumper shunt blocks.||
||SJ16||Selects between supplying 5V or 3V3 to the auxiliary serial device||
||SJ17||Selects either the 5V from the ESCs or the 5V from the system power supply for the headers connected to PORTA||
||SJ18||Joins the 5V from the USB bus to the 5V system power||

Important: If you select ground for SJ15, then do not select anything using SJ17, doing so will short-circuit the power supply connected to SJ17 with ground, which can cause damage to the various power supply components.

Important: If you select V-RC with SJ15 (to use the same voltage that the RC inputs are using) and you have selected 3V3 using SJ3, then you must not use SJ17 to select anything. Doing so will cause the 5V supply to be joined with the 3V3 supply, which can cause damage to 3V3 devices.

=Part List=

Note that in this list, all components are listed regardless of whether or not you need them.

The ATmega644PA and 40 pin DIP chip socket, !SparkFun breakout boards, XBee, Bluetooth Mate, and FTDI cables are not listed.

||Part||Other Attributes||Identifiers||Quantity Required||Example Product||
||4K7 ohm resistor||0805 or 0603 packaging, 1/16 W minimum||`R`1, `R`2, `R`9, `R`10||4||Digikey: P4.7KACT-ND||
||10K ohm resistor||0805 or 0603 packaging, 1/16 W minimum||`R`8, `R`11, `R`13||3||Digikey: P10KACT-ND||
||68R ohm resistor||0805 or 0603 packaging, 1/16 W minimum||`R`14, `R`15||2||Digikey: P68ACT-ND||
||2K2 ohm resistor||0805 or 0603 packaging, 1/16 W minimum||`R`16||1||Digikey: P2.2KACT-ND||
||15K ohm resistor||0805 or 0603 packaging, 1/16 W minimum||`R`6||1||Digikey: P15KACT-ND||
||7K5 ohm resistor||0805 or 0603 packaging, 1/16 W minimum||`R`7||1||Digikey: P7.5KACT-ND||
||1K ohm resistor||0805 or 0603 packaging, 1/16 W minimum||`R`3-5, `R`12||4||Digikey: P1.0KACT-ND||
||1 uF capacitor||ceramic, 0805 or 0603 packaging, 16V rating minimum||C3, C4||2||Digikey: 311-1358-1-ND||
||0.1 uF capacitor||ceramic, 0805 or 0603 packaging, 16V rating minimum||C1, C2, C7, C8, C9||5||Digikey: 311-1361-1-ND||
||33 uF capacitor||electrolytic, 5.3 mm x 5.3 mm SMD aluminum can, 16V rating minimum||C5, C6||2||Digikey: PCE3886CT-ND||
||4u7 capacitor||tantalum, 1210 package, rated 6V minimum||C10||1||Digikey: 478-3887-1-ND||
||1N4148 diode||MELF packaging||D1||1||Digikey: LL4148DICT-ND||
||Rectifier Diode||SMB packaging, 20V reverse voltage minimum, high forward current rating||D2||1||Digikey: SSB44-E3/52TGICT-ND||
||3V6 zener diode (1N5227B)||MELF packaging, 500 mW rating||D3, D4||2||Digikey: ZMM5227BDICT-ND||
||16 MHz resonator|| ||Y1 (16 MHz on PCB)||1||!SparkFun: COM-09420||
||Male headers||0.1 inch pitch||ESC, I2C, I2C-GROUP, BARO, ACCEL, IMU, GYRO, MAG, BATTERY, BATT-MON, ADC1-7, RC1-6, 5V-TAP, 3V3-TAP, SERIAL, FTDI, maybe BLUETOOTH||Buy long strips and break them off|| ||
||2x3 male headers||0.1 inch pitch, no shroud allowed||AVRISP||1||Use the male headers you buy||
||TXB0101 bidirectional level shifter||SOT-23-6 package||IC4, IC5||2||Digikey: 296-21664-1-ND||
||Tactile momentary push button switch SPST||Right angle, 7.50mm x 7.10mm||RESET, BOOT||2||Digikey: P12232SCT-ND||
||5V regulator||SOT223, SOT-223-3 package||5V-REG||1||LM1117MPX-5.0||
||3V3 regulator||SOT223 package||3V3-REG||1||LM1117MPX-3.3||
||LED||3 mm, any colour||LED1-4||4||!SparkFun: COM-00533||
||Barrel jack|| ||Battery||1||!SparkFun: PRT-00119||
||USB mini-B female connector||Surface mount||USB||1||!SparkFun: PRT-00587||
||2mm female pin headers|| ||Xbee||2||!SparkFun: PRT-08272||

=Pins=

Here is the pin chart for the ATmega644PA on the !AeroQuado64 PCB

||LED1, detecting USB cable presence||Digital 0 (Debug LED)||PB0||1||`+--v--+`||40||PA0, ADC0||Digital 31, Analog 0||Battery Monitor||
||LED2, USB bus D-||Digital 1||PB1||2||`o`||39||PA1, ADC1||Digital 30, Analog 1||GPIO, do anything||
||LED3, USB bus D+||Digital 2||PB2, INT2||3|| ||38||PA2, ADC2||Digital 29, Analog 2||GPIO, do anything||
||SERVO1 (camera pitch)||Digital 3 (PWM)||PB3||4|| ||37||PA3, ADC3||Digital 28, Analog 3||GPIO, do anything||
||SERVO2 (camera roll)||Digital 4 (PWM)||PB4||5|| ||36||PA4, ADC4||Digital 27, Analog 4||GPIO, do anything||
||SERVO3 (camera yaw), MOSI||Digital 5||PB5, MOSI||6|| ||35||PA5, ADC5||Digital 26, Analog 5||GPIO, do anything||
||SERVO4 (camera aux), MISO, BOOT button||Digital 6||PB6, MISO||7|| ||34||PA6, ADC6||Digital 25, Analog 6||GPIO, do anything||
||SCK||Digital 7||PB7, SCK||8|| ||33||PA7, ADC7||Digital 24, Analog 7||GPIO, do anything||
||RESET|| ||RESET||9|| ||32||AREF|| ||AREF||
||VCC|| ||VCC||10|| ||31||GND|| ||GND||
||GND|| ||GND||11|| ||30||AVCC|| ||AVCC||
||XTAL2|| ||XTAL2||12|| ||29||PC7, PCINT23||Digital 23||RC-IN-6, Auxiliary||
||XTAL1|| ||XTAL1||13|| ||28||PC6, PCINT22||Digital 22||RC-IN-5, Gear||
||SER0 RX||Digital 8, RX0||PD0, RXD0||14|| ||27||PC5, PCINT21||Digital 21||RC-IN-4, Pitch/Rudder||
||SER0 TX||Digital 9, TX0||PD1, TXD0||15|| ||26||PC4, PCINT20||Digital 20||RC-IN-3, Roll/Elevator||
||SER1 RX||Digital 10, RX1||PD2, RXD1||16|| ||25||PC3, PCINT19||Digital 19||RC-IN-2, Yaw/Aileron||
||SER1 TX||Digital 11, TX1||PD3, TXD1||17|| ||24||PC2, PCINT18||Digital 18||RC-IN-1, Throttle||
||ESC-BACK||Digital 12 (PWM)||PD4, OC1B||18|| ||23||PC1, SDA||Digital 17||SDA||
||ESC-RIGHT||Digital 13 (PWM)||PD5, OC1A||19|| ||22||PC0, SCL||Digital 16||SCL||
||ESC-FRONT||Digital 14 (PWM)||PD6, OC2B||20||`+-----+`||21||PD7, OC2A||Digital 15 (PWM)||ESC-LEFT||

Of course, a lot of this is configurable in the source code.

=The Common 3-Pin Cable=

Hey you! Are you about to plug something in? Take a look at this:

<img src="http://frank.circleofcurrent.com/junk/aq64_img/3pinservoref1.png" />

DO NOT EVER SCREW THIS UP!

=Setup Guide for !AeroQuado64 Source Code=

==The Sketch==

The sketch itself is a heavily modified version of !AeroQuad Flight Software V2.4 , which requires a special core developed for the !AeroQuado64 PCB.

When a new version of !AeroQuad becomes available, I will synchronize the changes between it and !AeroQaudo64's source code.

==Special ATmega644PA Core==

I'm using a modified Arduino core based on the Sanguino core.

I've included TWI code that is more efficient than the "Wire" I2C library (the Wire library is not suited for master-only operation). The old code still uses the Wire library but the new code gets used if `AeroQuado64` is defined.

`wiring.c` is modified so that timer0's overflow interrupt vector can be utilized to control servos without distrubing the functionality of the `millis()` function. My own timer0 servo control library called `SoftServo` is also incorporated into the core.

V-USB code is not utilized at the moment, but it is used for a bootloader variant.

Install the core by copying the folder `AeroQuado64Core` into your Arduino installation such that you create `\arduino-0022\hardware\arduino\cores\AeroQuado64Core\`.

You will also need to modify `boards.txt` to include the entry

{{{

AeroQuado64.name=AeroQuado64
AeroQuado64.upload.protocol=stk500
AeroQuado64.upload.maximum_size=57344
AeroQuado64.upload.speed=76800
AeroQuado64.bootloader.low_fuses=0xFF
AeroQuado64.bootloader.high_fuses=0x98
AeroQuado64.bootloader.extended_fuses=0xFF
AeroQuado64.bootloader.path=AeroQuado64Boot
AeroQuado64.bootloader.file=AeroQuado64Boot_arduino.hex
AeroQuado64.bootloader.unlock_bits=0x3F
AeroQuado64.bootloader.lock_bits=0x0F
AeroQuado64.build.mcu=atmega644p
AeroQuado64.build.f_cpu=16000000L
AeroQuado64.build.core=AeroQuado64Core

}}}

Note: settings in `boards.txt` will only take effect when you close and re-open Arduino IDE

===Bootloaders===

You'll need to change the `bootloader.file` and `upload.protocol` in `boards.txt' according to the bootloader you want to use.

Several special bootloaders are developed, copy the folder `AeroQuado64Boot` as `\arduino-0022\hardware\arduino\bootloaders\AeroQuado64Boot\`

`AeroQuado64Boot_arduino.hex` requires the stk500 protocol, and requires you to use a FTDI cable. Use it as if the AeroQuado64 is an Arduino without auto-reset. This bootloader has a timeout like the regular Arduino bootloader. It's been modified from the Sanguino bootloader.

`AeroQuado64Boot_stk500_w_btn.hex` requires the stk500 protocol, and requires you to use a FTDI cable. Hold down the BOOT button while clicking the RESET button, this bootloader will never time out. Pressing RESET without holding down BOOT will not engage the bootloader. Not having to wait and not having a timeout feels much better than the default Arduino bootloader.

`AeroQuado64Boot_usbasp.hex` requires the protocol to be set as `usbasp`. Add the line `AeroQuado64.upload.disable_flushing=true` Hold down the BOOT button while clicking the RESET button, this bootloader will never time out. Pressing RESET without holding down BOOT will not engage the bootloader. You can only use this if you have installed all of the components required for native USB. You'll also need the [http://www.fischl.de/usbasp/ drivers for USBasp from its website]. This bootloader does not occupy any serial ports, so you don't have to mess with constantly disconnecting, reconnecting, selecting, and configuring serial ports.

=Configuring the !AeroQuado64 Source Code=

You must decide what features you want, and configure the source code correctly before compiling and uploading the firmware to the microcontroller. The steps are very similar to how you would configure the original !AeroQuad source code.

==Mounting Orientation==

The !AeroQuado64 PCB supports both X and + configurations, see `AeroQuado64.pde` about `#define XConfig` and `#define plusConfig`.

==Flight Sensors==

Note: the original AeroQuad code has been changed to disable the AVR's internal pull-up resistors, this is so that the I2C bus can operate at 3V3 using the `R`1 and `R`2 as external pull-up resistors. The Wire library never accounted for the possibility of using an ATmega644PA so it enables internal pull-up resistors on the wrong pins, this is reverted manually in the new code.

===Gyro===

You absolutely must have a digital gyroscope sensor, and three axis of measurements are needed. They allow the flight control software to stabilize the quadrotor helicopter by adjusting motor speeds to counteract any unwanted rotation.

!AeroQuado64 has footprints to support:

 * ITG-3200 breakout board from !SparkFun
 * 6 DOF IMU breakout board from !SparkFun

These two boards actually are both using the ITG-3200 chip itself, so the source code configuration steps are the same.

See `AeroQuado64.pde` about `#define FlightAngleARG`, or `#define FlightAngleMARG` if a compass is used.

===Accelerometer===

Accelerometers will allow the software to use static acceleration measurements (aka gravity) to help determine the current flight angle. This will allow you to enable "stable" mode or "attitude" mode,

!AeroQuado64 has footprints to support:

 * 6 DOF IMU breakout board from !SparkFun
 * BMA180 breakout board from !SparkFun

The 6 DOF IMU breakoutboard uses a ADXL345, while the BMA180 breakout board obviously uses a BMA180.

see `AeroQuado64.pde` about `#define FlightAngleARG`, or `#define FlightAngleMARG` if a compass is used.

===Barometric Pressure Sensor===

There is a footprint available for the BMP085 barometric pressure sensor. This sensor can measure air pressure so that the software knows what altitude you are flying at. It is then able to adjust throttle to hold at a particular altitude. You need to enable this in the source code.

Please read `AeroQuado64.pde` about the `AltitudeHold` definition, which you need to enable.

===Magnetic Compass===

There is a footprint available for the HMC5842 hall effect sensor. This sensor can measure the Earth's magnetic fields to determine the current magnetic heading of the helicopter. It is then able to keep that direction constantly. You need to enable this in the source code.

Please read `AeroQuado64.pde' about the `HeadingMagHold` and `FlightAngleMARG` definitions, which you need to enable.

===Others===

The footprint for the ITG-3200 breakout board actually fits the IMU3000 breakout board from !SparkFun, and the pins are compatible. Somebody just needs to write the software for it.

==Battery Monitor==

If you have installed the components for the battery monitor circuit, then you can enable battery monitoring in the source code.

Enable the `BattMonitor` definition in `AeroQuado64.pde` if you want to use this capability.

Please see `BatteryMonitor.h` , where you can program the behaviour of the helicopter when the battery voltage reaches a certain level. For example, you can program it to slowly land, flash warning lights, etc.

You also need to get the precise measurements of the components used in your battery monitoring circuitry, this means the voltage drop across D1, and the values of `R`6 and `R`7. Put these values where indicated in `BatteryMonitor.h` .

==Wireless==

There's a place to put down a XBee module, and a place to put a Bluetooth Mate or BlueSMIRF module. See the hardware assembly guide about how to route the serial port signals to these connectors.

TODO: More instructions here. The XBee setup is similar to how you would have done it for the original !AeroQuad, and the bluetooth setup should be done according to the instruction provided for the module you are using.

==I2C ESCs==

Take a look at `Motors.h` for more information about using ESCs which use I2C. I've added a definition in `AeroQuado64.pde` called `USE_I2C_ESC` so you can use I2C ESCs instead.

==Camera or Auxiliary Servos==

I have made some changes to `Camera.h` to add a new camera class called "`AeroQuado64_Camera`" which uses my servo code (called !SoftServo) included in the core. `AeroQuado64.pde` will create an instance of this new class and use it in a similar fashion as how cameras are controlled in the origial !AeroQuad.

If you want the servos to do something else besides controlling a camera, the class is still "camera" but you simply use it for your own application. Use your head.

If you want direct RC control from your RC transmitter to the servo, this should not be done by the !AeroQuado64 PCB or software, instead you should be connecting your RC receiver directly to the servo instead.

Feel free to disable the camera code if you want to use those pins for something else.

==Other Stuff==

The original !AeroQuad code has some other code, such as for GPS, data logging, and others.

If you want to experiment with these, remember that I have incorporated auxiliary I2C, serial ports, GPIOs of all kinds, and SPI can be accessed through the ISP header.

USART0 is called "`Serial`" and USART1 is called "`Serial1`", remember that!

If you decide to use the PORTA GPIOs with jumper shunt blocks, you can modify the source code such that you compile all the options and use the blocks to select the option at runtime, so you don't have to constantly recompile in the field.

==!MultiWiiCopter?==

So I've taken a look at !MultiWiiCopter, and I might be able to get some of its features working. An untested sample modification of !MultiWiiCopter version 1.7 is included in the download above.

=Design Notes=

Most footprints support multiple device packaging, just in case you have something already on hand

No copper near where abrasion is expected (near around the FTDI connector, and the mounting slots)

No copper under the XBee antenna

No copper under the compass sensor

I did my best to label everything on the silk screen layer

All traces are 0.016" wide or greater. If you need to cut a trace, but then later want to re-connect it, the thick trace makes this easy for you.

Most header footprints have a tiny locking offset similar to how !SparkFun does it in their Eagle library, however my footprints are easier to center correctly.

I know !AeroQuad depends on all the timers except timer0 (reserved so `millis()` works) to control auxiliary servos on the Arduino Mega, so you might be wondering how I plan on controlling four more servos when the ATmega644PA only has timer0 available to use. Don't worry, I have compare match driven servo control code (called !SoftServo) that utilizes timer0 without disturbing the operation of `millis()`, and actually my code can target any pin on the ATmega, even the ones on PORTA (where there are 7 available GPIOs).

==Improvements Over Various !AeroQuad Shields==

Stop spending money on Arduinos and its cousins, being stand-alone means you can use your Arduino for other stuff without removing it from your aircraft. If you have money to blow on an Arduino Mega, blow it on something like a Teensy++ or mbed instead. (I might consider redoing this PCB to use the mbed later)

The !AeroQuad shields look kind of "Eagle auto-routed" (judging from the trace width, apparent routing grid, and weird cornering of the traces), I think I'm being very picky about this sort of stuff.

The shield had level shifting for the I2C which is totally unnessesary, but no level shifting for any serial port devices. My design has optinal level shifting for both serial ports, and I2C uses external pull-up resistors to 3V3 so it doesn't need level shifting.

The LEDs on the !AeroQuad V1.8 shield are supposed to be special LEDs with current limiting resistors built inside, but this makes it dangerous for anybody not using the same special LEDs. Also the LED on pin 13 can cause problems for any SPI devices and ISP programming.

The !AeroQuad shields do not provide a 3V3 supply, it uses the one built into the Arduino. The 3V3 supply from the Arduino boards before UNO are kind of bad, limited, and noisy.

==After Thoughts==

I didn't put any designation on the first batch of PCBs, version 1 is dated TODO and can be recognized by the test pattern on the PCB

===Version 1 After Thoughts===

This PCB might be *too* configurable for some people, but if you are smart enough to build a quadrotor helicopter, you better be smart enough to read this page.

AREF probably should just be connected directly to 3V3, since you can select 5V as the reference through software.

More attention could have been paid towards SPI, but nothing uses SPI yet. The ISP header is the only way to access the SPI signals. To experiment with SPI devices, I suggest you connect it with this header by using a 2X3 IDC cable, and then use a pin from PORTA or PORTB as the CS or SS signal. Remember that the voltage here is 5V and if your device uses 3V3, external level shifters might be needed. Luckily, there's two connectors (labelled 3V3-TAP) near the voltage regulators that give you access to 3V3.

The native USB stuff probably causes a lot of confusion. Just don't bother with it if you don't understand how to use it.

No mounting holes for IMU3000 breakout board, oh well, see [http://aeroquad.com/showthread.php?2655 this thread]

Timer1's ICP is not available for use since it is occupied by OC2B. However I do have working and tested code from a `non-AeroQuad` quadcopter that can use timer1 to drive 7 servos (via a decade counter or serial-to-parallel shift register) while reading PPM from ICP. (This code is not included, I'm just mentioning it so you know it's possible)

RSSI pin is not used on the XBee. Various shields on the market include a LED on this pin, but I think you can always just look at the ground station XBee's RSSI instead of the one that is flying.

INT0, INT1, and INT2 are the only external interrupt pins on the ATmega644PA, but there's no easy way to use them on this PCB. Good thing there are plenty of PCINT pins.

My code for the 4 camera/auxiliary servos work, but I'm not sure how having more interrupt routines will bother the rest of the time sensitive software.

`R`4's silkscreen is covering a via, this was because the USB stuff was added at the end.

I forgot to label the USB connector footprint with silkscreen text, although it is pretty obvious that it is for a USB mini B female connector.

I don't think there's a standard I2C cable, and my connectors for I2C ESCs are different from what's on the !AeroQuad Mega shield, but if you just follow the labelling on the pins, you'll have no problem making a custom 4 pin to 3 pin cable.

===Version 2 Future Plans===

See how useful the native USB is

Extensive testing with XBee to see if level shifting is actually required

Tie AREF to 3V3 by default, however, leave the solder jumper footprint

Maybe add trim-pots

Change the I2C ESC connectors slightly

Maybe move right to using the mbed, but that will probably be called another project

More to come...